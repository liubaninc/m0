// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: xmodel/xmodel.proto

package xmodel

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResourceType int32

const (
	ResourceType_NET    ResourceType = 0
	ResourceType_CPU    ResourceType = 1
	ResourceType_MEMORY ResourceType = 2
	ResourceType_DISK   ResourceType = 3
	ResourceType_XFEE   ResourceType = 4
)

var ResourceType_name = map[int32]string{
	0: "NET",
	1: "CPU",
	2: "MEMORY",
	3: "DISK",
	4: "XFEE",
}

var ResourceType_value = map[string]int32{
	"NET":    0,
	"CPU":    1,
	"MEMORY": 2,
	"DISK":   3,
	"XFEE":   4,
}

func (x ResourceType) String() string {
	return proto.EnumName(ResourceType_name, int32(x))
}

func (ResourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{0}
}

type GasPrice struct {
	CpuRate  int64 `protobuf:"varint,1,opt,name=cpu_rate,json=cpuRate,proto3" json:"cpu_rate,omitempty"`
	MemRate  int64 `protobuf:"varint,2,opt,name=mem_rate,json=memRate,proto3" json:"mem_rate,omitempty"`
	DiskRate int64 `protobuf:"varint,3,opt,name=disk_rate,json=diskRate,proto3" json:"disk_rate,omitempty"`
	XfeeRate int64 `protobuf:"varint,4,opt,name=xfee_rate,json=xfeeRate,proto3" json:"xfee_rate,omitempty"`
}

func (m *GasPrice) Reset()         { *m = GasPrice{} }
func (m *GasPrice) String() string { return proto.CompactTextString(m) }
func (*GasPrice) ProtoMessage()    {}
func (*GasPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{0}
}
func (m *GasPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPrice.Merge(m, src)
}
func (m *GasPrice) XXX_Size() int {
	return m.Size()
}
func (m *GasPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPrice.DiscardUnknown(m)
}

var xxx_messageInfo_GasPrice proto.InternalMessageInfo

func (m *GasPrice) GetCpuRate() int64 {
	if m != nil {
		return m.CpuRate
	}
	return 0
}

func (m *GasPrice) GetMemRate() int64 {
	if m != nil {
		return m.MemRate
	}
	return 0
}

func (m *GasPrice) GetDiskRate() int64 {
	if m != nil {
		return m.DiskRate
	}
	return 0
}

func (m *GasPrice) GetXfeeRate() int64 {
	if m != nil {
		return m.XfeeRate
	}
	return 0
}

type ResourceLimit struct {
	Type  ResourceType `protobuf:"varint,1,opt,name=type,proto3,enum=liubaninc.m0.xmodel.ResourceType" json:"type,omitempty"`
	Limit int64        `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ResourceLimit) Reset()         { *m = ResourceLimit{} }
func (m *ResourceLimit) String() string { return proto.CompactTextString(m) }
func (*ResourceLimit) ProtoMessage()    {}
func (*ResourceLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{1}
}
func (m *ResourceLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceLimit.Merge(m, src)
}
func (m *ResourceLimit) XXX_Size() int {
	return m.Size()
}
func (m *ResourceLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceLimit.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceLimit proto.InternalMessageInfo

func (m *ResourceLimit) GetType() ResourceType {
	if m != nil {
		return m.Type
	}
	return ResourceType_NET
}

func (m *ResourceLimit) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type WasmCodeDesc struct {
	Runtime      string `protobuf:"bytes,1,opt,name=runtime,proto3" json:"runtime,omitempty"`
	Compiler     string `protobuf:"bytes,2,opt,name=compiler,proto3" json:"compiler,omitempty"`
	Digest       []byte `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
	VmCompiler   string `protobuf:"bytes,4,opt,name=vm_compiler,json=vmCompiler,proto3" json:"vm_compiler,omitempty"`
	ContractType string `protobuf:"bytes,5,opt,name=contract_type,json=contractType,proto3" json:"contract_type,omitempty"`
}

func (m *WasmCodeDesc) Reset()         { *m = WasmCodeDesc{} }
func (m *WasmCodeDesc) String() string { return proto.CompactTextString(m) }
func (*WasmCodeDesc) ProtoMessage()    {}
func (*WasmCodeDesc) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{2}
}
func (m *WasmCodeDesc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WasmCodeDesc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WasmCodeDesc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WasmCodeDesc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmCodeDesc.Merge(m, src)
}
func (m *WasmCodeDesc) XXX_Size() int {
	return m.Size()
}
func (m *WasmCodeDesc) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmCodeDesc.DiscardUnknown(m)
}

var xxx_messageInfo_WasmCodeDesc proto.InternalMessageInfo

func (m *WasmCodeDesc) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *WasmCodeDesc) GetCompiler() string {
	if m != nil {
		return m.Compiler
	}
	return ""
}

func (m *WasmCodeDesc) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *WasmCodeDesc) GetVmCompiler() string {
	if m != nil {
		return m.VmCompiler
	}
	return ""
}

func (m *WasmCodeDesc) GetContractType() string {
	if m != nil {
		return m.ContractType
	}
	return ""
}

type VersionedData struct {
	PureData     *PureData `protobuf:"bytes,1,opt,name=pureData,proto3" json:"pureData,omitempty"`
	RefTxid      []byte    `protobuf:"bytes,2,opt,name=refTxid,proto3" json:"refTxid,omitempty"`
	RefMsgOffset int32     `protobuf:"varint,3,opt,name=refMsgOffset,proto3" json:"refMsgOffset,omitempty"`
	RefOffset    int32     `protobuf:"varint,4,opt,name=refOffset,proto3" json:"refOffset,omitempty"`
}

func (m *VersionedData) Reset()         { *m = VersionedData{} }
func (m *VersionedData) String() string { return proto.CompactTextString(m) }
func (*VersionedData) ProtoMessage()    {}
func (*VersionedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{3}
}
func (m *VersionedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedData.Merge(m, src)
}
func (m *VersionedData) XXX_Size() int {
	return m.Size()
}
func (m *VersionedData) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedData.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedData proto.InternalMessageInfo

func (m *VersionedData) GetPureData() *PureData {
	if m != nil {
		return m.PureData
	}
	return nil
}

func (m *VersionedData) GetRefTxid() []byte {
	if m != nil {
		return m.RefTxid
	}
	return nil
}

func (m *VersionedData) GetRefMsgOffset() int32 {
	if m != nil {
		return m.RefMsgOffset
	}
	return 0
}

func (m *VersionedData) GetRefOffset() int32 {
	if m != nil {
		return m.RefOffset
	}
	return 0
}

type PureData struct {
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Key    []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value  []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PureData) Reset()         { *m = PureData{} }
func (m *PureData) String() string { return proto.CompactTextString(m) }
func (*PureData) ProtoMessage()    {}
func (*PureData) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{4}
}
func (m *PureData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PureData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PureData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PureData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PureData.Merge(m, src)
}
func (m *PureData) XXX_Size() int {
	return m.Size()
}
func (m *PureData) XXX_DiscardUnknown() {
	xxx_messageInfo_PureData.DiscardUnknown(m)
}

var xxx_messageInfo_PureData proto.InternalMessageInfo

func (m *PureData) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *PureData) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *PureData) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// ContractResponse is the response returnd by contract
type ContractResponse struct {
	Status  int32  `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Body    []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *ContractResponse) Reset()         { *m = ContractResponse{} }
func (m *ContractResponse) String() string { return proto.CompactTextString(m) }
func (*ContractResponse) ProtoMessage()    {}
func (*ContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{5}
}
func (m *ContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractResponse.Merge(m, src)
}
func (m *ContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContractResponse proto.InternalMessageInfo

func (m *ContractResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ContractResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ContractResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type ContractEvent struct {
	Contract string `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Body     []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *ContractEvent) Reset()         { *m = ContractEvent{} }
func (m *ContractEvent) String() string { return proto.CompactTextString(m) }
func (*ContractEvent) ProtoMessage()    {}
func (*ContractEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe73b6d7dc3d196, []int{6}
}
func (m *ContractEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractEvent.Merge(m, src)
}
func (m *ContractEvent) XXX_Size() int {
	return m.Size()
}
func (m *ContractEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ContractEvent proto.InternalMessageInfo

func (m *ContractEvent) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *ContractEvent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContractEvent) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func init() {
	proto.RegisterEnum("liubaninc.m0.xmodel.ResourceType", ResourceType_name, ResourceType_value)
	proto.RegisterType((*GasPrice)(nil), "liubaninc.m0.xmodel.GasPrice")
	proto.RegisterType((*ResourceLimit)(nil), "liubaninc.m0.xmodel.ResourceLimit")
	proto.RegisterType((*WasmCodeDesc)(nil), "liubaninc.m0.xmodel.WasmCodeDesc")
	proto.RegisterType((*VersionedData)(nil), "liubaninc.m0.xmodel.VersionedData")
	proto.RegisterType((*PureData)(nil), "liubaninc.m0.xmodel.PureData")
	proto.RegisterType((*ContractResponse)(nil), "liubaninc.m0.xmodel.ContractResponse")
	proto.RegisterType((*ContractEvent)(nil), "liubaninc.m0.xmodel.ContractEvent")
}

func init() { proto.RegisterFile("xmodel/xmodel.proto", fileDescriptor_6fe73b6d7dc3d196) }

var fileDescriptor_6fe73b6d7dc3d196 = []byte{
	// 577 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xcb, 0x6e, 0xd3, 0x4c,
	0x14, 0x8e, 0x1b, 0xa7, 0x75, 0x4e, 0x93, 0x5f, 0xd6, 0xf4, 0x17, 0x2a, 0xb7, 0x00, 0x46, 0x48,
	0x88, 0x45, 0x52, 0x15, 0xb1, 0x60, 0x05, 0x22, 0x0d, 0x88, 0x4b, 0x69, 0x35, 0x2d, 0x50, 0x10,
	0x52, 0x35, 0xb1, 0x8f, 0xc3, 0xa8, 0x19, 0xdb, 0xf2, 0x8c, 0x43, 0xc2, 0x53, 0xf0, 0x0c, 0x2c,
	0x78, 0x16, 0x96, 0x5d, 0xb2, 0x44, 0xed, 0x8b, 0xa0, 0xb9, 0x38, 0x80, 0xd4, 0x95, 0xcf, 0x77,
	0xbe, 0x73, 0xbe, 0x73, 0xf3, 0xc0, 0xc6, 0x5c, 0xe4, 0x09, 0x4e, 0x07, 0xf6, 0xd3, 0x2f, 0xca,
	0x5c, 0xe5, 0x64, 0x63, 0xca, 0xab, 0x31, 0xcb, 0x78, 0x16, 0xf7, 0xc5, 0x56, 0xdf, 0x52, 0xd1,
	0x17, 0x08, 0x9e, 0x31, 0xb9, 0x5f, 0xf2, 0x18, 0xc9, 0x65, 0x08, 0xe2, 0xa2, 0x3a, 0x2e, 0x99,
	0xc2, 0x4d, 0xef, 0xa6, 0x77, 0xb7, 0x49, 0xd7, 0xe2, 0xa2, 0xa2, 0x4c, 0x19, 0x4a, 0xa0, 0xb0,
	0xd4, 0x8a, 0xa5, 0x04, 0x0a, 0x43, 0x5d, 0x85, 0x76, 0xc2, 0xe5, 0x89, 0xe5, 0x9a, 0x86, 0x0b,
	0xb4, 0xa3, 0x26, 0xe7, 0x29, 0xa2, 0x25, 0x7d, 0x4b, 0x6a, 0x87, 0x26, 0xa3, 0x8f, 0xd0, 0xa5,
	0x28, 0xf3, 0xaa, 0x8c, 0xf1, 0x15, 0x17, 0x5c, 0x91, 0x07, 0xe0, 0xab, 0x45, 0x61, 0x8b, 0xff,
	0xb7, 0x7d, 0xab, 0x7f, 0x41, 0xc3, 0xfd, 0x3a, 0xe3, 0x70, 0x51, 0x20, 0x35, 0xe1, 0xe4, 0x7f,
	0x68, 0x4d, 0x75, 0xbe, 0xeb, 0xcc, 0x82, 0xe8, 0x9b, 0x07, 0x9d, 0x77, 0x4c, 0x8a, 0x61, 0x9e,
	0xe0, 0x0e, 0xca, 0x98, 0x6c, 0xc2, 0x5a, 0x59, 0x65, 0x8a, 0x0b, 0x5b, 0xa0, 0x4d, 0x6b, 0x48,
	0xae, 0x40, 0x10, 0xe7, 0xa2, 0xe0, 0x53, 0x2c, 0x8d, 0x46, 0x9b, 0x2e, 0x31, 0xb9, 0x04, 0xab,
	0x09, 0x9f, 0xa0, 0x54, 0x66, 0xb6, 0x0e, 0x75, 0x88, 0xdc, 0x80, 0xf5, 0x99, 0x38, 0x5e, 0xa6,
	0xf9, 0x26, 0x0d, 0x66, 0x62, 0x58, 0x27, 0xde, 0x86, 0x6e, 0x9c, 0x67, 0xaa, 0x64, 0xb1, 0x3a,
	0x36, 0x53, 0xb5, 0x4c, 0x48, 0xa7, 0x76, 0xea, 0x01, 0xa2, 0xef, 0x1e, 0x74, 0xdf, 0x62, 0x29,
	0x79, 0x9e, 0x61, 0xb2, 0xc3, 0x14, 0x23, 0x0f, 0x21, 0x28, 0xaa, 0x12, 0xb5, 0x6d, 0xda, 0x5c,
	0xdf, 0xbe, 0x7e, 0xe1, 0x1e, 0xf6, 0x5d, 0x10, 0x5d, 0x86, 0x9b, 0x01, 0x31, 0x3d, 0x9c, 0xf3,
	0xc4, 0x4c, 0xd1, 0xa1, 0x35, 0x24, 0x11, 0x74, 0x4a, 0x4c, 0x77, 0xe5, 0x64, 0x2f, 0x4d, 0x25,
	0xda, 0x51, 0x5a, 0xf4, 0x1f, 0x1f, 0xb9, 0x06, 0xed, 0x12, 0x53, 0x17, 0xe0, 0x9b, 0x80, 0x3f,
	0x8e, 0xe8, 0x05, 0x04, 0x75, 0x45, 0xbd, 0x92, 0x71, 0x15, 0x9f, 0xa0, 0x72, 0x7b, 0x74, 0x88,
	0x84, 0xd0, 0x3c, 0xc1, 0x85, 0xab, 0xad, 0x4d, 0x7d, 0x99, 0x19, 0x9b, 0x56, 0xe8, 0x76, 0x67,
	0x41, 0x74, 0x04, 0xe1, 0xd0, 0x2d, 0x81, 0xa2, 0x2c, 0xf2, 0x4c, 0xa2, 0xd6, 0x94, 0x8a, 0xa9,
	0x4a, 0x1a, 0xcd, 0x16, 0x75, 0x48, 0xcf, 0x24, 0x50, 0x4a, 0x36, 0x41, 0x77, 0x99, 0x1a, 0x12,
	0x02, 0xfe, 0x38, 0x4f, 0x16, 0x4e, 0xda, 0xd8, 0xd1, 0x01, 0x74, 0x6b, 0xe5, 0xd1, 0x0c, 0x33,
	0x65, 0x2f, 0x6b, 0x1d, 0xae, 0xd9, 0x25, 0xd6, 0x02, 0x19, 0x13, 0xb5, 0xae, 0xb1, 0x2f, 0x12,
	0xbd, 0xf7, 0x18, 0x3a, 0x7f, 0xff, 0x74, 0x64, 0x0d, 0x9a, 0xaf, 0x47, 0x87, 0x61, 0x43, 0x1b,
	0xc3, 0xfd, 0x37, 0xa1, 0x47, 0x00, 0x56, 0x77, 0x47, 0xbb, 0x7b, 0xf4, 0x7d, 0xb8, 0x42, 0x02,
	0xf0, 0x77, 0x9e, 0x1f, 0xbc, 0x0c, 0x9b, 0xda, 0x3a, 0x7a, 0x3a, 0x1a, 0x85, 0xfe, 0x93, 0x47,
	0x3f, 0xce, 0x7a, 0xde, 0xe9, 0x59, 0xcf, 0xfb, 0x75, 0xd6, 0xf3, 0xbe, 0x9e, 0xf7, 0x1a, 0xa7,
	0xe7, 0xbd, 0xc6, 0xcf, 0xf3, 0x5e, 0xe3, 0xc3, 0x9d, 0x09, 0x57, 0x9f, 0xaa, 0x71, 0x3f, 0xce,
	0xc5, 0x60, 0x79, 0xe5, 0x81, 0xd8, 0x1a, 0xcc, 0x07, 0x9f, 0x99, 0x14, 0xee, 0x01, 0x8f, 0x57,
	0xcd, 0x0b, 0xbe, 0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x25, 0xb7, 0xad, 0xa9, 0xd8, 0x03, 0x00,
	0x00,
}

func (m *GasPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XfeeRate != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.XfeeRate))
		i--
		dAtA[i] = 0x20
	}
	if m.DiskRate != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.DiskRate))
		i--
		dAtA[i] = 0x18
	}
	if m.MemRate != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.MemRate))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuRate != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.CpuRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WasmCodeDesc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WasmCodeDesc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WasmCodeDesc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractType) > 0 {
		i -= len(m.ContractType)
		copy(dAtA[i:], m.ContractType)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.ContractType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VmCompiler) > 0 {
		i -= len(m.VmCompiler)
		copy(dAtA[i:], m.VmCompiler)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.VmCompiler)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Compiler) > 0 {
		i -= len(m.Compiler)
		copy(dAtA[i:], m.Compiler)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Compiler)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionedData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionedData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefOffset != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.RefOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.RefMsgOffset != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.RefMsgOffset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RefTxid) > 0 {
		i -= len(m.RefTxid)
		copy(dAtA[i:], m.RefTxid)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.RefTxid)))
		i--
		dAtA[i] = 0x12
	}
	if m.PureData != nil {
		{
			size, err := m.PureData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintXmodel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PureData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PureData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PureData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintXmodel(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintXmodel(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintXmodel(dAtA []byte, offset int, v uint64) int {
	offset -= sovXmodel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GasPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuRate != 0 {
		n += 1 + sovXmodel(uint64(m.CpuRate))
	}
	if m.MemRate != 0 {
		n += 1 + sovXmodel(uint64(m.MemRate))
	}
	if m.DiskRate != 0 {
		n += 1 + sovXmodel(uint64(m.DiskRate))
	}
	if m.XfeeRate != 0 {
		n += 1 + sovXmodel(uint64(m.XfeeRate))
	}
	return n
}

func (m *ResourceLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovXmodel(uint64(m.Type))
	}
	if m.Limit != 0 {
		n += 1 + sovXmodel(uint64(m.Limit))
	}
	return n
}

func (m *WasmCodeDesc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Runtime)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Compiler)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.VmCompiler)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.ContractType)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	return n
}

func (m *VersionedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PureData != nil {
		l = m.PureData.Size()
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.RefTxid)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	if m.RefMsgOffset != 0 {
		n += 1 + sovXmodel(uint64(m.RefMsgOffset))
	}
	if m.RefOffset != 0 {
		n += 1 + sovXmodel(uint64(m.RefOffset))
	}
	return n
}

func (m *PureData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	return n
}

func (m *ContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovXmodel(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	return n
}

func (m *ContractEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovXmodel(uint64(l))
	}
	return n
}

func sovXmodel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozXmodel(x uint64) (n int) {
	return sovXmodel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GasPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRate", wireType)
			}
			m.CpuRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRate", wireType)
			}
			m.MemRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskRate", wireType)
			}
			m.DiskRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XfeeRate", wireType)
			}
			m.XfeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XfeeRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ResourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WasmCodeDesc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WasmCodeDesc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WasmCodeDesc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compiler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmCompiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmCompiler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PureData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PureData == nil {
				m.PureData = &PureData{}
			}
			if err := m.PureData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTxid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefTxid = append(m.RefTxid[:0], dAtA[iNdEx:postIndex]...)
			if m.RefTxid == nil {
				m.RefTxid = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefMsgOffset", wireType)
			}
			m.RefMsgOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefMsgOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefOffset", wireType)
			}
			m.RefOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PureData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PureData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PureData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXmodel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthXmodel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXmodel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthXmodel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXmodel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXmodel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXmodel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthXmodel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupXmodel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthXmodel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthXmodel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXmodel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupXmodel = fmt.Errorf("proto: unexpected end of group")
)
